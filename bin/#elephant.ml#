open Notty_unix
open Ui
open Utils
open Effect
open Effect.Deep
open Engine
open Entity
open World

type state_type = Stunned | Charging | Looking

class elephant entity_instance =
  object
    inherit entity entity_instance
    val mutable stunned = 0
    val mutable charge = 0
    val mutable charge_direction = (0, 0)
    val mutable state = Looking


    method get_stunned = stunned
    method set_stunned new_stunned = stunned <- new_stunned

    method get_charge = charge
    method set_charge new_charge = charge <- new_charge

    method get_charge_direction = charge_direction
    method set_charge_direction new_charge_direction = charge_direction <- new_charge_direction
  
    method get_state = state
    method set_state new_state = state <- new_state
  end

let rec camel_on_sight_direction (current_position : int * int) (direction : int * int) : bool =
  match current_position with
  | (x, y) ->
    (
      try (match world.(x).(y) with
           | Empty -> camel_on_sight_direction (current_position ++ direction) direction
           | Camel -> true
           | _ -> false
          )
      with
      | _ -> false
    )

let camel_on_sight (current_position : int * int) : (int * int) =
  if camel_on_sight_direction (current_position ++ (- 1, 0)) (- 1, 0) then (- 1, 0)
  else if camel_on_sight_direction (current_position ++ (+ 1, 0)) (+ 1, 0) then (+ 1, 0)
  else if camel_on_sight_direction (current_position ++ (0, + 1)) (0, + 1) then (0, + 1)
  else if camel_on_sight_direction (current_position ++ (0, - 1)) (0, - 1) then (0, - 1)
  else (0, 0)


(** [elephant_direction ()]
    TODO .*)
let random_direction () : int * int =
  let random_move = (Random.int 4) in
  match random_move with
  | 0 -> (- 1, 0) (*Left*)
  | 1 -> (+ 1, 0) (*Right*)
  | 2 -> (0, + 1) (*Down*)
  | 3 -> (0, - 1) (*Up*)
  | _ -> (0, 0) (*Exhaustive pattern*)

(** [elephant current_pos]  TODO *)
let rec elephant (elephant_instance : elephant) : unit =
  
  (match elephant_instance#get_state with
   | Stunned -> Printf.printf "Stunned : %d\n" elephant_instance#get_stunned;
   | Charging -> Printf.printf "Charging : %d\n" elephant_instance#get_charge;
   |_ -> Printf.printf "Other\n";);
  let current_position = elephant_instance#get_pos in
  let new_position =
    match elephant_instance#get_state with
    | Looking -> 
       begin
         match (camel_on_sight current_position) with
         | (0, 0) -> current_position ++ random_direction ()
         | direction ->
            (
              elephant_instance#set_charge_direction direction;
              elephant_instance#set_charge 9;
              elephant_instance#set_state Charging;
              current_position ++ direction
            )
       end

    | Charging -> 
       elephant_instance#set_charge (elephant_instance#get_charge -1);
       if elephant_instance#get_charge = 0 then
         begin
           elephant_instance#set_state Looking
         end;
       current_position ++ elephant_instance#get_charge_direction

    | Stunned -> 
       elephant_instance#set_stunned (elephant_instance#get_stunned -1);
       if elephant_instance#get_stunned = 0 then
         begin
           elephant_instance#set_state Looking
         end;
       current_position
  in
  
  let new_position = move current_position new_position in
  let is_blocked = (new_position = current_position) in
  match (is_blocked, elephant_instance#get_state) with
  | (true, Charging) ->
     begin
       elephant_instance#set_state Stunned;
       elephant_instance#set_stunned 20
     end
  | _ -> ();
         
         elephant_instance#set_pos new_position;
         perform End_of_turn;
         elephant elephant_instance